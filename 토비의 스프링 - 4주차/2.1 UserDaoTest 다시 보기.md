# 2.1 UserDaoTest 다시보기

## 2.1.1 테스트의 유용성

테스트란?
- 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업.

## 2.1.2 UserDaoTest 의 특징

```java
public class UserDaoTest {
	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
		UserDao dao = context.getBean("userDao", UserDao.class);

		User user = new User();
		user.setId("whiteship");
		user.setName("백기선");
		user.setPassword("married");

		dao.add(user);
			
		System.out.println(user.getId() + " 등록 성공");
		
		User user2 = dao.get(user.getId());
		System.out.println(user2.getName());
		System.out.println(user2.getPassword());
			
		System.out.println(user2.getId() + " 조회 성공");
	}
}
```

- 자바에서 가장 손쉽게 실행 가능한 `main()` 메소드를 이용한다.
- 테스트할 대상인 `UserDao`의 오브젝트를 가져와 메소드를 호출한다.
- 테스트에 사용할 입력 값(`User` 오브젝트)을 직접 코드에서 만들어 넣어준다.
- 테스트의 결과를 콘솔에 출력해준다.
- 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지로 출력해준다.

이 테스트 방법에서 가장 돋보이는 건, 

`main()` 메소드를 이용해 `쉽게 테스트 수행을 가능하게 했다는 점`과 테스트할 대상인 `UserDao`를 `직접 호출해서 사용`한다는 점.

### 웹을 통한 DAO 테스트 방법의 문제점

보통 웹 프로그램에서 사용하는 `DAO` 를 테스트 하는 방법은 다음과 같다.

1. `DAO` 를 만든 뒤 바로 테스트하지 않고, 서비스 계층, `MVC` 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다.
2. 이렇게 만들어진 테스트용 웹 애플리케이션을 서버에 배치한 뒤, 웹 화면을 띄워 폼을 열고, 값을 입력한 뒤 버튼을 눌러 등록해본다.
3. 이를 위해서는 폼의 값을 받아서 파싱한 뒤에 `User` 오브젝트로 만들고 `UserDao`를 호출해주는 기능이 이미 만들어져 있어야 한다.
4. 여기까지 해서 에러가 없으면 이번엔 검색 폼이나 파라미터를 지정할 수 있는 `URL`을 사용해서 방금 입력한 데이터를 다시 가져올 수 있는지 테스트 해본다. 역시 `UserDao` 가 돌려주는 결과를 화면에 출력해주는 기능이 만들어져 있어야 확인이 가능하다.

__`DAO`에 대한 테스트로서는 단점이 너무 많다.__

`DAO` 뿐만 아니라 서비스 클래스, 컨트롤러, `JSP` 뷰 등 __모든 레이어의 기능을 다 만들고 나여샤 테스트가 가능하다는 점이 가장 큰 문제__.

하나의 테스트를 수행하는 데 참여하는 클래스와 코드가 너무 많기 때문에,

- 테스트 중 에러가 나거나 테스트가 실패했다면, __어디에서 문제가 발생했는지를 찾아내야 하는 수고도 필요__.

정작 테스트할 대상인 `DAO`의 문제가 아니라 서버환경에서 웹 화면을 통해 `DAO` 를 테스트하려고 만든 다른 코드 때문에 에러가 나거나 테스트가 실패할 수도 있다.

테스트하고 싶었던 건 `UserDao` 였으나 다른 계층의 코드와 컴포넌트, 심지어 서버의 설정 상태까지 __모두 테스트에 영향을 줄 수 있기 때문에__ 이런 방식으로 테스트하는 것은 __번거롭고__, 오류가 있을 때 **빠르고 정확하게 대응하기가 힘들다는 문제**가 있다.

### 작은 단위의 테스트

테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다.

테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다. 관심사의 분리라는 원리가 여기에도 적용된다.
- **테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근**해야 한다.

작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트 `unit test` 라고 한다. 

여기서 말하는 단위란 무엇이지, 그 크기와 범위가 어느 정도인지 딱 정해진 건 아니다.

크게는 사용자 관리 기능을 모두 통틀어서 하나의 단위로 볼 수도 있고, 작게 보자면 `UserDao`의 `add()` 메소드 하나만 가지고 하나의 단위라고 생각할 수도 있다.

**충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위**라고 보면 된다.

일반적으로 단위는 작을 수록 좋다. 단위를 넘어서는 다른 코드들은 신경쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다.

`UserDao`는 서비스, `MVC` 계층이 참여하고 웹 화면과 서버까지 동원하지 않고도 테스트가 가능했다. `DAO`라는 기능과 `DB`까지로 단위를 잡고 집중해서 테스트할 수 있었다. 그래서 `UserDaoTest`를 단위 테스트라고 부를 수 있다.

> 어떤 개발자는 테스트 중에 DB가 사용되면 단위 테스트가 아니라고도 한다. 그럼 `UserDaoTest`는 단위 테스트가 아니라고 봐야 할까?   
>
> 그렇지는 앖다. 지금까지 `UserDaoTest`를 수행할 때 매번 `USER` 테이블의 내용을 비우고 테스트를 진행했다.   
> 이렇게 사용할 `DB`의 상태를 테스트가 관장하고 있다면 이는 단위 테스트라고 해도 된다.   
> 다만, `DB`의 상태가 매번 달라지고, 테스트를 위해 `DB`를 특정 상태로 만들어줄 수 없다면 그때는 `UserDaoTest`가 단위 테스트로서 가치가 없어진다.
>
> 그런 차원에서 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 하는 것이다.

때로는 웹 사용자 인터페이스부터 시작해서 `DB`에 이르기까지의 애플리케이션 전 계층이 참여하고, 또 단순 사용자 등록 작업 하나가 아니라, 초기 등록에서부터 시작해서 등록이 성공하면 로그인하고, 각종 기능을 모두 사용한 다음에 로그아웃까지 하는 전 과정을 하나로 묶어서 테스트할 필요가 있다. 각 단위 기능들은 잘 동작하는데 묶어놓으면 안되는 경우가 종종 발생하기 때문이다.

각 단위별로 테스트를 먼저 모두 진행하고 나서 이런 긴 테스트를 시작했다면 어떨가? 그래도 역시 예외가 발생하거나 테스트가 실패할 수는 있겠지만, 이미 각 단위별로 충분한 검증을 마치고 오류를 잡았으므로 훨씬 나을 것이다.

단위 테스트를 하는 이유는 __개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인 받기 위해서다__.

이때 __확인의 대상과 조건이 간단하고 명확할수록 좋다.__ 그래서 작은 단위로 제한해서 테스트하는 것이 편리하다.

### 자동수행 테스트 코드

`UserDaoTest` 의 한 가지 특징은 **테스트할 데이터가 코드를 통해 제공**되고, **테스트 작업 역시 코드를 통해 자동으로 실행한다는 점**이다.

테스트는 자동으로 수행되도록 **코드로 만들어지는 것이 중요**하다.

그런데 애플리케이션을 구성하는 클래스 안에 테스트 코드를 포함시키는 것보다는 **별도로 테스트용 클래스를 만들어서** 테스트 코드를 넣는 편이 낫다.

> 지금까지의 과정을 정리해보면,  
> `UserDao` Class 생성 => `main()` method 추가 => 클래스를 분리하고 유연한 설계구조로 발전 => `UserDaoTest` Class 생성

자동으로 수행되는 테스트의 장점은 **자주 반복할 수 있다는 것**이다.

번거로운 작업이 없고 테스트를 빠르게 실행할 수 있기 때문에 언제든 코드를 수정하고 나서 테스트를 해 볼 수 있다.

### 지속적인 개선과 점진적인 개발을 위한 테스트

일단 자신 있게 만들 수 있는 가장 단순한 방법으로 `DAO` 코드를 만들자마자 바로 `DAO`로서의 기능에 문제가 없는지 검증해주는 테스트 코드를 만들어뒀기 때문에, 그때부터는 자신을 가지고 조금씩 코드를 개선해나가는 작업을 진행할 수 있었다.

일단은 단순 무식한 방법으로 정상동작하는 코드를 만들고, 테스트를 만들어뒀기 때문에 매우 작은 단계를 거쳐가면서 계속 코드를 개선해나갈 수 있었다.

또 `UserDao` 의 기능을 추가하려고 할 때도 미리 만들어둔 테스트 코드는 유용하게 쓰일 수 있다.

**일단은 가장 단순한 등록과 조회 기능을 만들고**, 이를 **테스트로 검증해서 만든 코드에 대한 확신을 갖는다**. 그리고 거기에 **조금씩 기능을 더 추가**해가면서 그에 대한 **테스트도 함꼐 추가**하는 식으로 **점진적인 개발**이 가능해진다.

테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라, 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수도 있다.

## 2.1.3 UserDaoTest 의 문제점

### 수동 확인 작업의 번거로움

테스트 수행은 코드에 의해 자동으로 진행되나 테스트의 결과를 확인하는 일은 사람의 책임이므로 완전히 자동으로 테스트되는 방법이라고 말할 수가 없다.
 
 ### 실행 작업의 번거로움
 
아무리 간단히 실행 가능한 `main()` 메소드라고 하더라도 매번 그것을 실행하는 것은 번거롭다.

만약 `DAO`가 수백 개가 되고 그에 대한 `main()` 메소드도 그만큼 만들어진다면, 전체 기능을 테스트해보기 위해 `main()` 메소드를 수백 번 실행하는 수고가 필요하다.
  